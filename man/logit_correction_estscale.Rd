% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/logit_correction_estscale.r
\name{logit_correction_estscale}
\alias{logit_correction_estscale}
\title{Full information model with Dahl's correction function that estimates scale instead of cost (for personal MC use)}
\usage{
logit_correction_estscale(starts3, dat, otherdat, alts)
}
\arguments{
\item{starts3}{Starting values as a vector (num). For this likelihood, the order takes:
c([marginal utility from catch], [catch function parameters], [polynomial starting parameters], [catch sigma], [scale parameter]). \cr \cr
The number of polynomial interaction terms is currently set to 2, so given the chosen degree 'polyn' there should be (((polyn+1)*2) + 2)*kk polynomial
starting parameters, where kk equals the number of alternatives. The marginal utility from catch, scale parameter, and catch sigma are of length 1 respectively.
The catch function parameters are of length (# of catch variables)*kk.}

\item{dat}{Data matrix, see output from shift_sort_x, alternatives with distance.}

\item{otherdat}{Other data used in model (as list containing objects griddat, intdat, startloc, polyn, and distance. \cr \cr
Any number of grid-specific variables are allowed, as a list of matrices. Note for this likelihood only one interaction variable
is allowed (as we are estimating the scale parameter given a cost parameter set to (-1)), as a list of a single matrix. 
Note the variables (each as a matrix) within `griddat` and `intdat` have no naming restrictions. 
Also note that `griddat` variables are dimension *(number of observations) x (number of alternatives)*, 
while `intdat` variables are dimension *(number of observations) x 1*, to be interacted with the distance to each alternative.
Grid-specific variables may correspond to catches that vary by location, 
or interaction variables may be vessel characteristics that affect how much disutility is suffered by traveling a greater distance.
Note in this likelihood the grid-specific variables are the variables in the catch equation, and
each variable varies across observations but not for each location: they are grid-specific due to the location-specific coefficients. 
If there are no other data, the user can set `griddat` as ones with dimension *(number of observations) x (number of alternatives)*
and `intdat` variables as ones with dimension *(number of observations) x 1*. \cr \cr
The variable startloc is a matrix of dimension *(number of observations) x 1*, 
that corresponds to the starting location when the agent decides between alternatives. \cr \cr
The variable polyn is a vector of length 1 corresponding to the chosen polynomial degree. \cr \cr
The variable distance is a matrix of dimension *(number of observations) x (number of alternatives)* corresponding to the distance to each alternative.}

\item{alts}{Number of alternative choices in model as length 1 vector (num).}
}
\value{
ld: negative log likelihood
}
\description{
Full information model with Dahl's correction function that estimate scales instead of cost (for personal MC use)
}
\section{Details}{

The computation of the Nth Fibonacci number in this function uses the
formula obtained from solving the recurrence relation 
\deqn{F_{n} = F_{n-1} + F_{n-2},} which translates to the equation, 
\eqn{x^{n} = x^{n-1} + x^{n-2}}, and then to \eqn{x^2=x+1}. The two 
solutions to the latter equation  are \eqn{\phi} and \eqn{\psi}, where 
\deqn{\phi=\frac{1+\sqrt{5}}{2}, \qquad \psi=\frac{1-\sqrt{5}}{2}.}
This eventually leads to the formula used in this function,
\deqn{F_{n} =\frac{\phi^{n} - \psi^{n}}{\sqrt{5}}.}
}

\examples{
data(zi)
data(catch)
data(choice)
data(distance)
data(si)
data(startloc)

optimOpt <- c(1000,1.00000000000000e-08,1,0)

methodname <- "BFGS"

polyn <- 3
kk <- 4

si2 <- sample(1:5,dim(si)[1],replace=TRUE)

otherdat <- list(griddat=list(si=as.matrix(cbind(si,si,si,si)),si2=as.matrix(cbind(si2,si2,si2,si2))),
			intdat=list(zi=as.matrix(zi)),startloc=as.matrix(startloc),polyn=polyn,distance=as.matrix(distance))

initparams <- c(3, 0.5, 0.4, 0.3, 0.2, 0.55, 0.45, 0.35, 0.25, rep(0, (((polyn+1)*2) + 2)*kk), 1, 3)

func <- logit_correction_estscale

results <- discretefish_subroutine(catch,choice,distance,otherdat,initparams,optimOpt,func,methodname)

}
